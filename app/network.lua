--
-- Copyright © 2007 All Rights Reserved.
--

module("Network", package.seeall)

local lgid = "network"

local led_status = "off"
local carrier_status = nil
local upping_network = false

--
-- Open a file, or die with a fatal error message when failed
--

local function open_or_die(fname, mode)
	local fd,err = io.open(fname, mode)
	if not fd then
		logf(LG_WRN, lgid, "Could not open file '%s': %s", fname, err)
		return io.open("/dev/null", mode)
	end
	return fd
end


--
-- Generate configuration files for ethernet
--

local function configure_ethernet(network)

	logf(LG_DBG, lgid, "Configuring Ethernet connection")

	-- /etc/network/interfaces part
	
	local fd = open_or_die(network.fname_interfaces, "a")
	fd:write("auto eth0\n")

	local dhcp = config:get("/network/dhcp")

	if dhcp == "true" then
		fd:write("iface eth0 inet dhcp\n")
		fd:write("  vendor NQuire200\n")
	else
		fd:write("iface eth0 inet static\n")
		fd:write("  address " .. config:get("/network/ip/address") .. "\n")
		fd:write("  netmask " .. config:get("/network/ip/netmask") .. "\n")
		fd:write("  gateway " .. config:get("/network/ip/gateway") .. "\n")
	end
	fd:write("  pre-up killall udhcpc; true\n")
	fd:write("\n")
	fd:close()

	-- resolv.conf
	
	if dhcp == "false" and config:get("/network/interface")~="gprs" then
		local fd = open_or_die(network.fname_resolv_conf, "w")
		fd:write("nameserver " .. config:get("/network/ip/ns1") .. "\n")
		fd:write("nameserver " .. config:get("/network/ip/ns2") .. "\n")
		fd:close()
	end

end


--
-- Generate configuration files for wifi
--

local function configure_wifi(network)

	if not Network:wlan_is_available() then
		return
	end

	logf(LG_DBG, lgid, "Configuring wifi connection")
	
	local dhcp = config:get("/network/dhcp")
	local key = config:get("/network/wifi/key")
	local keytype = config:get("/network/wifi/keytype")
	local essid = config:get("/network/wifi/essid")

	-- Create wpa_supplicant.conf in /tmp
	
	local fd = open_or_die("/tmp/wpa_supplicant.conf", "w")

	fd:write("network={\n")
	fd:write("	ssid=\"%s\"\n" % essid)
	fd:write("	scan_ssid=1\n")

	if keytype == "off" then
		fd:write("	key_mgmt=NONE\n")
	elseif keytype == "WEP" then
		fd:write("	key_mgmt=NONE\n")
		fd:write("	wep_key0=%s\n" % key)
		fd:write("	wep_tx_keyidx=0\n")
	elseif keytype == "WPA / WPA2" then
		fd:write("	key_mgmt=WPA-PSK\n")
		fd:write("	psk=\"%s\"\n" % key)
	end
	fd:write("}\n")
	fd:close()


	-- /etc/network/interfaces part. The double setting of the SSID is 
	-- a workaround for the rt73 not associating right away. The wonders of
	-- wifi :(
	
	local fd = open_or_die(network.fname_interfaces, "a")
	
	if dhcp == "true" then
		fd:write("iface wlan0 inet dhcp\n")
	else
		fd:write("iface wlan0 inet static\n")
		fd:write("  address " .. config:get("/network/ip/address") .. "\n")
		fd:write("  netmask " .. config:get("/network/ip/netmask") .. "\n")
		fd:write("  gateway " .. config:get("/network/ip/gateway") .. "\n")
	end
	fd:write("  pre-up killall udhcpc; true\n")
	fd:write("  pre-up killall wpa_supplicant; true\n")
	fd:write("  pre-up wpa_supplicant -B -iwlan0 -c/tmp/wpa_supplicant.conf\n")
	fd:write("  pre-down killall wpa_supplicant; true\n")

	fd:write("\n")
	fd:close()

	-- resolv.conf
	
	if dhcp == "false" and config:get("/network/interface")~="gprs" then
		local fd = open_or_die(network.fname_resolv_conf, "w")
		fd:write("nameserver " .. config:get("/network/ip/ns1") .. "\n")
		fd:write("nameserver " .. config:get("/network/ip/ns2") .. "\n")
		fd:close()
	end

end


--
-- Generate configuration files for GPRS network
--

local function configure_gprs(network)
	
	if not Network:gprs_is_available() then
		return
	end

	logf(LG_DBG, lgid, "Configuring GPRS connection")
	
	-- /etc/interfaces section
	local fd = open_or_die(network.fname_interfaces, "a")
	fd:write(string.format([[
iface gprs inet ppp
  pre-up killall udhcpc; true
  provider gprs
  post_up /etc/ppp/ip-up
  pre-down /etc/ppp/ip-down

]]))
	fd:close()

	-- ip-up (could be included in the image, for now, just generate)
	-- But it should be better to let the name-resolver use /etc/ppp/resolv.conf
	local fd = open_or_die("/etc/ppp/ip-up", "w")
	fd:write(string.format([[
#!/bin/sh

RC=/etc/resolv.conf
RCO=$RC.org

if ! grep "generated by /etc/ppp/ip-up" $RC > /dev/null; then
	cp $RC $RCO
fi

echo "# generated by /etc/ppp/ip-up" > $RC
                              
# TODO FIX: for some unknown reason the following condition does not work:
#if test -n "$USEPEERDNS"; then
#	if test -n "$DNS1"; then
		echo "nameserver $DNS1" >> $RC
#	if
#	if test -n "$DNS2"; then
		echo "nameserver $DNS2" >> $RC
#	if
#fi
]]))
	fd:close()

	-- ip-down (could be included in the image, for now, just generate)
	local fd = open_or_die("/etc/ppp/ip-down", "w")
	fd:write(string.format([[
RC=/etc/resolv.conf
RCO=$RC.org

if grep "generated by /etc/ppp/ip-up" $RC > /dev/null; then
	if test -f $RCO; then
		rm -f $RC
		mv $RCO $RC
	fi
fi
]]))
	fd:close()
	os.execute("chmod +x /etc/ppp/ip-up /etc/ppp/ip-down")

	-- PPPD peer options file
	
	local fd = open_or_die(network.fname_peer, "w")
	local username = config:get("/network/gprs/username")
	if username~="" then
		fd:write("user " .. username .. "\n")
		-- and write password to chap-secrets
		local chapfd = open_or_die(network.fname_chap_secrets, "w")
		chapfd:write(username .. " * " .. config:get("/network/gprs/password"))
		chapfd:close()
	end
	fd:write(string.format([[
%s %s
connect %s
disconnect %s
crtscts 
lock
updetach
hide-password
defaultroute
usepeerdns
holdoff 3
ipcp-accept-local
lcp-echo-failure 8
lcp-echo-interval 3
noauth
noipdefault
novj
novjccomp
nodeflate
nobsdcomp
#replacedefaultroute
persist
lcp-echo-interval 3
lcp-echo-failure 12
	]], 
	config:get("/dev/modem/device"),
	config:get("/dev/modem/baudrate"),
	network.fname_chat_connect,
	network.fname_chat_disconnect))
	fd:close()

	-- Connect script

	local fd = open_or_die(network.fname_chat_connect, "w")
	fd:write(string.format([[
#!/bin/sh -e
exec /usr/bin/chat -V -s -S \
	ABORT BUSY \
	ABORT DELAYED \
	ABORT "NO ANSWER" \
	ABORT "NO DIALTONE" \
	ABORT VOICE \
	ABORT ERROR \
	ABORT RINGING \
	TIMEOUT 3 \
	"" ATZ \
	OK-\\k\\k\\k\\d+++ATH-OK ATE1 \
	OK AT+CPIN? \
	CPIN:\\sREADY-\\dAT+CPIN=%s-OK "" \
	TIMEOUT 30 \
	"" AT+CGDCONT=1,\"IP\",\"%s\",,0,0 \
	OK ATD%s \
	CONNECT \\d\\c \
	"" ""]], 
	config:get("/network/gprs/pin"),
	config:get("/network/gprs/apn"),
	config:get("/network/gprs/number")))
	fd:close()
	os.execute("chmod +x " .. network.fname_chat_connect)

	-- Disconnect script

	local fd = open_or_die(network.fname_chat_disconnect, "w")
	fd:write([[
#!/bin/sh -e
exec /usr/bin/chat -V -s -S\
	ABORT OK\
	ABORT BUSY\
	ABORT DELAYED\
	ABORT "NO ANSWER"\
	ABORT "NO CARRIER"\
	ABORT "NO DIALTONE"\
	ABORT VOICE\
	ABORT ERROR\
	ABORT RINGING\
	TIMEOUT 12\
	"" \\k\\k\\k\\d+++ATH\
	"NO CARRIER-AT-OK" ""
	]])
	fd:close()
	os.execute("chmod +x " .. network.fname_chat_disconnect)

	-- Chap secrets

	local fd = open_or_die(network.fname_chap_secrets, "w")
	fd:write(string.format("%s \"\" %s\n",
		config:get("/network/gprs/username"),
		config:get("/network/gprs/password")
	))
	fd:close()

end


-- 
-- Configure network by writing out various network configuration files
--

local function configure(network)

	logf(LG_INF, lgid, "Configuring interfaces")
	
	local fd = open_or_die(network.fname_interfaces, "w")
	fd:write("# Auto-generated by validator application, do not edit\n")
	fd:write("\n")
	fd:write("auto lo\n")
	fd:write("iface lo inet loopback\n")
	fd:write("\n")
	fd:close()

	configure_ethernet(network)
	configure_gprs(network)
	configure_wifi(network)

end


-- return true for carrier up, false for down, or nil for unknown
local function get_carrier_status()
	local status = io.input ( "/sys/class/net/eth0/carrier" ):read(1)
	if status == nil then
		return nil
	else
		return status == "1"
	end
end

local function get_macaddress(node)
	local serial = sys.get_macaddr("eth0")
	node:setraw(serial)
end


local function get_current_ip_addr()
	local fd = io.popen("/sbin/ifconfig")
	local ipaddr = nil
	if fd then
		ipaddr = fd:read("*all"):match("inet addr:(%S+)")
		fd:close()
	end
	return ipaddr
end


--
-- Bring up network
--
local function up(network)

	local cmd = ""

	-- Don't update network configuration if we're running from NFS
    -- Watch out: this is actually debug code!
	local mounts = io.open("/proc/mounts"):read("*a")
	if mounts:match("root / nfs") then
		logf(LG_WRN, lgid, "Root filesystem is on NFS, not configuring network")
		return
	end

	local interface = config:get("/network/interface")
	if		interface == "wifi" and Network:wlan_is_available() or
			interface == "gprs" and Network:gprs_is_available() or 
			interface == "ethernet" then
		logf(LG_INF, lgid, "Upping network on %s", interface )
	else
		logf(LG_WRN, lgid, "No hardware for network on interface %s", interface )
		beeper:beep_error()
		return
	end

	local current_ip = get_current_ip_addr()

	if not opt.n then
		cmd = cmd .. "ifdown -f eth0; "
	else
		logf(LG_DBG,lgid, "opt -n found: not shutting down eth0")
	end
	if Network:wlan_is_available() then
		cmd = cmd .. "ifdown -f wlan0; "
	end
	if Network:gprs_is_available() then
		cmd = cmd .. "ifdown gprs; "
	end

	cmd = cmd .. "sleep 5;"

	if interface == "ethernet" then
		if not opt.n then
			cmd = cmd .. "ifup -f eth0"
		end
	elseif interface == "wifi" then
		cmd = cmd .. "ifup -f wlan0"
	elseif interface == "gprs" then
		cmd = cmd .. "sleep 5; ifup gprs"
	else
		logf(LG_WRN, lgid, "Unknown interface '%s'. Not starting network.", interface)
		return
	end

	evq:push("network_down")
	led:set("blue", "flash")
	network.is_up = false

	logf(LG_INF, lgid, "Bringing up network %s interface", interface)

	logf(LG_DMP, lgid, "Running %q", cmd)
	upping_network = true
	runbg(cmd, 
		function(status,network)
			if status ~= 0 then
				logf(LG_WRN, lgid, "An error occured configuring the network: %d", status)
			else
				local ip = get_current_ip_addr() or "?.?.?.?"
				logf(LG_INF, lgid, "Configured network successfully: %s", ip)
				network.is_up = true
				evq:push("network_up")
			end
			upping_network = false
		end,
		function(data,network)
			logf(LG_DMP, lgid, "ifup> %s", data)
		end,
		network)

end


local function get_current_ip(node)
	local ipaddr = get_current_ip_addr()
	if ipaddr then
		node:setraw(ipaddr)
	else
		node:setraw("?")
	end
end


-- TODO: implement an event based solution
local function on_check_network_status_timer( event, nw )
	local new_led_status = "flash"
	local current_carrier_status = get_carrier_status()
	local interface = config:get("/network/interface")
	local current_ip_addr = get_current_ip_addr()
	
	if nw.is_up and current_ip_addr and (interface ~= "ethernet" or current_carrier_status == true) then
		new_led_status = "on"
	end
	if new_led_status ~= led_status then
		led_status = new_led_status;
		led:set("blue", led_status)
		if led_status == "on" then
			logf(LG_INF,lgid,"Network is up")
		elseif not upping_network then
			logf(LG_INF,lgid,"Network is down")
		end
	end

	if current_carrier_status ~= nil then
		if interface == "ethernet" and carrier_status ~= current_carrier_status and carrier_status ~= nil then
			if current_carrier_status then
				logf(LG_INF, lgid, "Carrier restored")
			else
				logf(LG_WRN, lgid, "Network error: Carrier lost (network re-init or cable failure)")
			end
		end
		carrier_status = current_carrier_status
	end

	return true;
end

local has_gprs_hw
function gprs_is_available()
	if has_gprs_hw == nil then
		has_gprs_hw = false
		if not Scanner_1d:is_available() then
			local dev = config:get("/dev/modem/device")
			local fd = sys.open(dev, "r")
			if fd then
				sys.close(fd)
				fd = sys.open(dev, "rw")
				sys.set_baudrate(fd,tonumber(config:get("/dev/modem/baudrate")))
				sys.tcflush(fd)
				sys.write(fd,"AT\r")
				local data = sys.readport( fd, 20, 1000 )
				logf(LG_DBG,lgid,"gprs_is_available() data='%s'", (data or "<nil>"))
				has_gprs_hw = data and data:find("OK") and true or false;
				logf(LG_INF,lgid,"%sGRPS hardware detected.", (has_gprs_hw and "" or "No "))
				sys.close(fd)
			else
				logf(LG_WRN,lgid,"GPRS modem device '%s' not found (should probably be ttyS1).", dev )
			end
		end
	end
	return has_gprs_hw
end

local has_wlan_hw = nil
function wlan_is_available()
	if has_wlan_hw == nil then
		has_wlan_hw = false
		local fd = io.popen("iwconfig", "r")
		if fd then
			for l in fd:lines() do
				if l:match("wlan0") then
					has_wlan_hw = true
				end
			end
			fd:close()
		end
	end
	return has_wlan_hw
end

--
-- Constructor
--

function new()

	local netwrk = {

		-- data
		fname_resolv_conf     = "/etc/resolv.conf",
		fname_interfaces      = "/etc/network/interfaces",
		fname_peer            = "/etc/ppp/peers/gprs",
		fname_chat_connect    = "/etc/ppp/gprs-connect-chat",
		fname_chat_disconnect = "/etc/ppp/gprs-disconnect-chat",
		fname_chap_secrets    = "/etc/ppp/chap-secrets",
		is_up                 = false,

		-- methods
		configure = configure,
		up = up,
	}
	
	evq:signal_add("SIGCHLD")

	local function	reconfigure(node, nw) 
		print("Reconfiguring network")
		nw:configure()
		nw:up()
	end

	carrier_status = get_carrier_status()

	config:add_watch("/network/macaddress", "get", get_macaddress, netwrk)
	config:add_watch("/network/current_ip", "get", get_current_ip, netwrk)
	config:add_watch("/network", "set", reconfigure, netwrk)
	config:add_watch("/dev/modem", "set", reconfigure, netwrk)

	evq:register("check_network_status_timer", on_check_network_status_timer, netwrk)
	evq:push("check_network_status_timer", nil, 5.0)

	return netwrk
end
	

-- vi: ft=lua ts=3 sw=3 
