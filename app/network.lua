--
-- Copyright © 2007 All Rights Reserved.
--

module("Network", package.seeall)

local lgid = "network"

local led_status = "off"
local carrier_status = nil
local upping_network = false
local again = false
local wlan_signal_strength = nil
local config_is_changed = false

--
-- Open a file, or die with a fatal error message when failed
--

local function open_or_die(fname, mode)
	local fd,err = io.open(fname, mode)
	if not fd then
		logf(LG_WRN, lgid, "Could not open file '%s': %s", fname, err)
		return io.open("/dev/null", mode)
	end
	return fd
end


--
-- Generate configuration files for ethernet
--

local function configure_ethernet(network)

	logf(LG_DBG, lgid, "Configuring Ethernet connection")

	-- /etc/network/interfaces part
	
	local fd = open_or_die(network.fname_interfaces, "a")
	fd:write("auto eth0\n")

	local dhcp = config:get("/network/dhcp")

	if dhcp == "true" then
		fd:write("iface eth0 inet dhcp\n")
		fd:write("  vendor NQuire200\n")
	else
		fd:write("iface eth0 inet static\n")
		fd:write("  address " .. config:get("/network/ip/address") .. "\n")
		fd:write("  netmask " .. config:get("/network/ip/netmask") .. "\n")
		fd:write("  gateway " .. config:get("/network/ip/gateway") .. "\n")
	end
	fd:write("  pre-up while killall udhcpc; do sleep .1; done; true\n")
	fd:write("\n")
	fd:close()

	-- resolv.conf
	
	if dhcp == "false" and config:get("/network/interface")~="gprs" then
		local fd = open_or_die(network.fname_resolv_conf, "w")
		fd:write("nameserver " .. config:get("/network/ip/ns1") .. "\n")
		fd:write("nameserver " .. config:get("/network/ip/ns2") .. "\n")
		fd:close()
	end

end


--
-- Generate configuration files for wifi
--

local function configure_wifi(network)

	logf(LG_DBG, lgid, "Configuring wifi connection")
	
	local dhcp = config:get("/network/dhcp")
	local key = config:get("/network/wifi/key")
	local keytype = config:get("/network/wifi/keytype")
	local essid = config:get("/network/wifi/essid")

	-- Create wpa_supplicant.conf in /tmp
	
	local fd = open_or_die("/tmp/wpa_supplicant.conf", "w")

	fd:write("network={\n")
	fd:write("	ssid=\"%s\"\n" % essid)
	fd:write("	scan_ssid=1\n")

	if keytype == "off" then
		fd:write("	key_mgmt=NONE\n")
	elseif keytype == "WEP" then
		fd:write("	key_mgmt=NONE\n")
		fd:write("	wep_key0=%s\n" % key)
		fd:write("	wep_tx_keyidx=0\n")
	elseif keytype == "WPA / WPA2" then
		fd:write("	key_mgmt=WPA-PSK\n")
		fd:write("	psk=\"%s\"\n" % key)
	end
	fd:write("}\n")
	fd:close()


	-- /etc/network/interfaces part. The double setting of the SSID is 
	-- a workaround for the rt73 not associating right away. The wonders of
	-- wifi :(
	
	local fd = open_or_die(network.fname_interfaces, "a")
	
	if dhcp == "true" then
		fd:write("iface wlan0 inet dhcp\n")
	else
		fd:write("iface wlan0 inet static\n")
		fd:write("  address " .. config:get("/network/ip/address") .. "\n")
		fd:write("  netmask " .. config:get("/network/ip/netmask") .. "\n")
		fd:write("  gateway " .. config:get("/network/ip/gateway") .. "\n")
	end
	fd:write("  pre-up while killall udhcpc wpa_supplicant; do sleep .1; done; true\n")
	fd:write("  pre-up wpa_supplicant -B -iwlan0 -c/tmp/wpa_supplicant.conf\n")
	fd:write("  post-down while killall wpa_supplicant; do sleep .1; done; true\n")

	fd:write("\n")
	fd:close()

	-- resolv.conf
	
	if dhcp == "false" and config:get("/network/interface")~="gprs" then
		local fd = open_or_die(network.fname_resolv_conf, "w")
		fd:write("nameserver " .. config:get("/network/ip/ns1") .. "\n")
		fd:write("nameserver " .. config:get("/network/ip/ns2") .. "\n")
		fd:close()
	end

end


--
-- Generate configuration files for GPRS network
--

local function configure_gprs(network)
	
	logf(LG_DBG, lgid, "Configuring GPRS connection")
	
	-- /etc/interfaces section
	local fd = open_or_die(network.fname_interfaces, "a")
	fd:write(string.format([[
iface gprs inet ppp
  pre-up while killall udhcpc; do sleep .1; done; true
  provider gprs
  post_up /etc/ppp/ip-up
  pre-down /etc/ppp/ip-down

]]))
	fd:close()

	-- ip-up (could be included in the image, for now, just generate)
	-- But it should be better to let the name-resolver use /etc/ppp/resolv.conf
	local fd = open_or_die("/etc/ppp/ip-up", "w")
	fd:write(string.format([[
#!/bin/sh

RC=/etc/resolv.conf
RCO=$RC.org

if ! grep "generated by /etc/ppp/ip-up" $RC > /dev/null; then
	cp $RC $RCO
fi

echo "# generated by /etc/ppp/ip-up" > $RC
                              
# TODO FIX: for some unknown reason the following condition does not work:
#if test -n "$USEPEERDNS"; then
#	if test -n "$DNS1"; then
		echo "nameserver $DNS1" >> $RC
#	if
#	if test -n "$DNS2"; then
		echo "nameserver $DNS2" >> $RC
#	if
#fi
]]))
	fd:close()

	-- ip-down (could be included in the image, for now, just generate)
	local fd = open_or_die("/etc/ppp/ip-down", "w")
	fd:write(string.format([[
RC=/etc/resolv.conf
RCO=$RC.org

if grep "generated by /etc/ppp/ip-up" $RC > /dev/null; then
	if test -f $RCO; then
		rm -f $RC
		mv $RCO $RC
	fi
fi
]]))
	fd:close()
	os.execute("chmod +x /etc/ppp/ip-up /etc/ppp/ip-down")

	-- PPPD peer options file
	
	local fd = open_or_die(network.fname_peer, "w")
	local username = config:get("/network/gprs/username")
	if username~="" then
		fd:write("user " .. username .. "\n")
		-- and write password to chap-secrets
		local chapfd = open_or_die(network.fname_chap_secrets, "w")
		chapfd:write(username .. " * " .. config:get("/network/gprs/password"))
		chapfd:close()
	end
	fd:write(string.format([[
%s %s
connect %s
disconnect %s
crtscts 
lock
updetach
hide-password
defaultroute
usepeerdns
holdoff 3
ipcp-accept-local
lcp-echo-failure 8
lcp-echo-interval 3
noauth
noipdefault
novj
novjccomp
nodeflate
nobsdcomp
#replacedefaultroute
persist
lcp-echo-interval 3
lcp-echo-failure 12
	]], 
	config:get("/dev/modem/device"),
	config:get("/dev/modem/baudrate"),
	network.fname_chat_connect,
	network.fname_chat_disconnect))
	fd:close()

	-- Connect script

	local fd = open_or_die(network.fname_chat_connect, "w")
	fd:write(string.format([[
#!/bin/sh -e
exec /usr/bin/chat -V -s -S \
	ABORT BUSY \
	ABORT DELAYED \
	ABORT "NO ANSWER" \
	ABORT "NO DIALTONE" \
	ABORT VOICE \
	ABORT ERROR \
	ABORT RINGING \
	TIMEOUT 3 \
	"" ATZ \
	OK-\\k\\k\\k\\d+++ATH-OK ATE1 \
	OK AT+CPIN? \
	CPIN:\\sREADY-\\dAT+CPIN=%s-OK "" \
	TIMEOUT 30 \
	"" AT+CGDCONT=1,\"IP\",\"%s\",,0,0 \
	OK ATD%s \
	CONNECT \\d\\c \
	"" ""]], 
	config:get("/network/gprs/pin"),
	config:get("/network/gprs/apn"),
	config:get("/network/gprs/number")))
	fd:close()
	os.execute("chmod +x " .. network.fname_chat_connect)

	-- Disconnect script

	local fd = open_or_die(network.fname_chat_disconnect, "w")
	fd:write([[
#!/bin/sh -e
exec /usr/bin/chat -V -s -S\
	ABORT OK\
	ABORT BUSY\
	ABORT DELAYED\
	ABORT "NO ANSWER"\
	ABORT "NO CARRIER"\
	ABORT "NO DIALTONE"\
	ABORT VOICE\
	ABORT ERROR\
	ABORT RINGING\
	TIMEOUT 12\
	"" \\k\\k\\k\\d+++ATH\
	"NO CARRIER-AT-OK" ""
	]])
	fd:close()
	os.execute("chmod +x " .. network.fname_chat_disconnect)

	-- Chap secrets

	local fd = open_or_die(network.fname_chap_secrets, "w")
	fd:write(string.format("%s \"\" %s\n",
		config:get("/network/gprs/username"),
		config:get("/network/gprs/password")
	))
	fd:close()

end


-- 
-- Configure network by writing out various network configuration files
--

local function configure(network)

	logf(LG_INF, lgid, "Configuring interfaces")
	--print("DEBUG: Configure: stack=" .. debug.traceback())
	
	local fd = open_or_die(network.fname_interfaces, "w")
	fd:write("# Auto-generated by validator application, do not edit\n")
	fd:write("\n")
	fd:write("auto lo\n")
	fd:write("iface lo inet loopback\n")
	fd:write("\n")
	fd:close()

	configure_ethernet(network)
	configure_wifi(network)
	configure_gprs(network)

end


-- return true for carrier up, false for down, or nil for unknown
local function get_carrier_status()
	local fd_status = io.input ( "/sys/class/net/eth0/carrier" )
	if fd_status then
		local status = fd_status:read(1)
		fd_status:close()
		if status == nil then
			return nil
		else
			return status == "1"
		end
	else
		return nil
	end
end


local function get_macaddress(node)
	local serial = sys.get_macaddr("eth0")
	node:setraw(serial)
end


local function get_current_ip_addr()

	local convert_to_itf = { ["ethernet"] = "eth0", ["wifi"]="wlan0", ["gprs"]="gprs" }
	local itf = convert_to_itf[config:get("/network/interface")]

	local ip, err = net.get_interface_ip( itf )
	
	if err then
		logf(LG_DMP,lgid,"Interface %s: %s", itf, err)
	end
	--logf(LG_DMP,lgid,"ip('%s')=%s", itf, (ip or "nil"))
	return ip
	
end


--
-- Bring up network
--
local function up(network)

	local cmd = ""

	if upping_network then
		logf(LG_WRN,lgid, "Double upping network: delayed")
		again = true
		os.execute("killall udhcpc wpa_supplicant ifup")
		return
	end
	again = false

	if config_is_changed then
		configure( network )
		config_is_changed=false
	end

	local interface = config:get("/network/interface")
	if		interface == "wifi" and not Network:wlan_is_available() or
			interface == "gprs" and not Network:gprs_is_available() then
		logf(LG_WRN, lgid, "No hardware for network on interface %s", interface )
		beeper:beep_error()
		return
	end

	local current_ip = get_current_ip_addr()

	if not opt.n then
		cmd = cmd .. "ifdown -f eth0; "
	else
		logf(LG_DBG,lgid, "opt -n found: not shutting down eth0")
	end
	if Network:wlan_is_available() then
		cmd = cmd .. "ifdown -f wlan0; "
	end
	if Network:gprs_is_available() then
		cmd = cmd .. "ifdown gprs; "
	end

	cmd = cmd .. "sleep 1;"

	if interface == "ethernet" then
		if not opt.n then
			cmd = cmd .. "ifup eth0"
		end
	elseif interface == "wifi" then
		cmd = cmd .. "ifup wlan0"
	elseif interface == "gprs" then
		cmd = cmd .. "sleep 2; ifup gprs"
	else
		logf(LG_WRN, lgid, "Unknown interface '%s'. Not starting network.", interface)
		return
	end

	if network.is_up then
		-- network_down with delay = -1 (don't queue, handle direct) so things can be
		-- done (e.g. closing tcp connections) before the network is really down.
		evq:push("network_down", nil, -1)
		network.is_up = false
	end
	led:set("blue", "flash")

	logf(LG_INF, lgid, "Bringing up network %s interface", interface)

	--print("DEBUG: Up() stack=" .. debug.traceback())
	
	logf(LG_DMP, lgid, "Running %q", cmd)
	upping_network = true
	runbg(cmd, 
		function(status,network)
			if status ~= 0 then
				logf(LG_WRN, lgid, "An error occured configuring the network: %d", status)
				again = true
			else
				local ip = get_current_ip_addr() or "?.?.?.?"
				logf(LG_INF, lgid, "Configured network successfully: %s", ip)		
				if not again then
					network.is_up = true
					evq:push("network_up")
				end
			end
			upping_network = false
			if again then
				up(network)
			end
		end,
		function(data,network)
			logf(LG_DMP, lgid, "ifup> %s", data)
		end,
		network)

end


local function get_current_ip(node)
	local ipaddr = get_current_ip_addr()
	if ipaddr then
		node:setraw(ipaddr)
	else
		node:setraw("?")
	end
end

local prev_signalstrength = -256
local function get_wlan_signal_strength( itf )
	local fd = io.open("/proc/net/wireless")
	if not fd then
		logf(LG_WRN, lgid, "Could not open /proc/net/wireless")
		return nil
	end
	local ss = tonumber(fd:read("*all"):match(itf .. ":%s+%d+%s+%d+.%s*(%-?%d+)"))
	fd:close()
	
	if ss and ss~=prev_signalstrength then
		logf(LG_DMP,lgid,"%s signal strength=%d", itf, ss)
		prev_signalstrength=ss
	end
	return tonumber(ss)
end

local function on_check_network_status_timer( event, nw )
	local new_led_status = "flash"
	local current_carrier_status = get_carrier_status()
	local interface = config:get("/network/interface")
	local current_ip_addr = get_current_ip_addr()
	
	if nw.is_up and current_ip_addr then
		if	interface == "ethernet"  then
			if not upping_network and 
					carrier_status ~= current_carrier_status and 
					carrier_status ~= nil then
				if current_carrier_status then
					logf(LG_INF, lgid, "Carrier restored")
				else
					logf(LG_WRN, lgid, "Network error: Carrier lost (network re-init or cable failure)")
				end
			end
			if current_carrier_status == true then
				new_led_status = "on"
			end
		elseif interface == "wifi" then
			new_wlan_signal_strength = get_wlan_signal_strength( "wlan0" )
			if wlan_signal_strength and new_wlan_signal_strength then
				if new_wlan_signal_strength>=-255 then
					new_led_status = "on"
					if wlan_signal_strength<-255 then
						logf(LG_INF, lgid, "wifi signal recovered")
					end
				elseif wlan_signal_strength>=-255 then
					logf(LG_WRN, lgid, "wifi signal lost. (%d dB)",
							new_wlan_signal_strength)
				end
			end
			if new_wlan_signal_strength then
				wlan_signal_strength = new_wlan_signal_strength
			end
		end
	end

	if current_carrier_status ~= nil then
		carrier_status = current_carrier_status
	end

	if new_led_status ~= led_status then
		led_status = new_led_status;
		led:set("blue", led_status)
		if led_status == "on" then
			logf(LG_INF,lgid,"Network is up")
		elseif not upping_network then
			logf(LG_INF,lgid,"Network is down")
			if interface == "wifi" and not Network:wlan_is_available() then
				logf(LG_WRN,lgid,"wifi is down unexpected.")
			end
		end
	end

	if interface == "wifi" and not upping_network and not current_ip_addr 
			and Network:wlan_is_available() then
		logf(LG_WRN,lgid,"Trying to re-init the network.")
 		up(nw)
	end

	return true;
end


local function on_interface_changed(node, nw)
	if config:get("/network/interface")=="wifi" then
		os.execute("/cit200/reload_wlan_driver.sh &")
	else
		os.execute("while killall reload_wlan_driver.sh; do sleep .1; done")
	end
end


local has_gprs_hw
function gprs_is_available()
	if has_gprs_hw == nil then
		has_gprs_hw = false
		if not Scanner_1d:is_available() then
			local dev = config:get("/dev/modem/device")
			local fd = sys.open(dev, "r")
			if fd then
				sys.close(fd)
				fd = sys.open(dev, "rw")
				sys.set_baudrate(fd,tonumber(config:get("/dev/modem/baudrate")))
				sys.tcflush(fd)
				sys.write(fd,"AT\r")
				local data = sys.readport( fd, 20, 1000 )
				logf(LG_DBG,lgid,"gprs_is_available() data='%s'", (data or "<nil>"))
				has_gprs_hw = data and data:find("OK") and true or false;
				if has_gprs_hw then
					logf(LG_INF,lgid,"GPRS hardware detected.") 
				else
					logf(LG_DBG,lgid,"No GPRS hardware detected.") 
				end
				sys.close(fd)
			else
				logf(LG_WRN,lgid,"GPRS modem device '%s' not found (should probably be ttyS1).", dev )
			end
		end
	end
	return has_gprs_hw
end


function wlan_is_available()

	local fd = io.open("/sys/class/net/wlan0","r")
	if fd then
		fd:close()
		return true
	else
		return false
	end

end


--
-- Constructor
--

function new()

	local netwrk = {

		-- data
		fname_resolv_conf     = "/etc/resolv.conf",
		fname_interfaces      = "/etc/network/interfaces",
		fname_peer            = "/etc/ppp/peers/gprs",
		fname_chat_connect    = "/etc/ppp/gprs-connect-chat",
		fname_chat_disconnect = "/etc/ppp/gprs-disconnect-chat",
		fname_chap_secrets    = "/etc/ppp/chap-secrets",
		is_up                 = false,

		-- methods
		configure = configure,
		up = up,
	}
	
	evq:signal_add("SIGCHLD")

	config:add_watch("/network/macaddress", "get", get_macaddress, netwrk)
	config:add_watch("/network/current_ip", "get", get_current_ip, netwrk)

	carrier_status = get_carrier_status()
	
	local function	reconfigure(node, nw) 
		-- print("Reconfiguring network")
		-- reconfigure signal with delay -1 (don't queue: handle direct) so 
		-- connections can be closed before the network goes down
		config_is_changed = true;
		evq:push("network_reconfigure",nil,-1)
		nw:up()
	end

	config:add_watch("/network", "set", reconfigure, netwrk)
	config:add_watch("/dev/modem", "set", reconfigure, netwrk)
	config:add_watch("/network/interface", "set", on_interface_changed, netwrk)
	on_interface_changed(nil,netwrk)

	evq:register("check_network_status_timer", on_check_network_status_timer, netwrk)
	evq:push("check_network_status_timer", nil, 2.0)

	netwrk:configure()
	
	return netwrk
end
	

-- vi: ft=lua ts=3 sw=3 
